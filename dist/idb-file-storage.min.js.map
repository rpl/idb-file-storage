{"version":3,"sources":["idb-file-storage.js"],"names":["waitForDOMRequest","req","onsuccess","Promise","resolve","reject","result","onerror","error","getFileStorage","name","persistent","filesStorage","IDBFileStorage","initializedDB","IDBPromisedFileHandle","constructor","file","lockedFile","writeQueue","closed","aborted","ensureLocked","invalidMode","Error","mode","active","reopenFileHandle","close","flush","abort","getMetadata","readAsText","size","location","readAsArrayBuffer","truncate","append","data","write","queuedWrite","then","lastLocation","waitForQueuedWrites","IDBPromisedMutableFile","idb","fileName","fileType","mutableFile","fileHandle","open","getFile","persistAsFileSnapshot","snapshotName","runFileRequestGenerator","objectStore","getObjectStoreTransaction","put","bind","get","persist","generatorFunction","fileRequestsIter","processFileRequestIter","prevRequestResult","nextFileRequest","next","done","value","window","DOMRequest","IDBRequest","throw","request","indexedDBName","objectStorageName","initializedPromise","version","IDBMutableFile","storage","dbReq","indexedDB","onupgradeneeded","db","objectStoreNames","contains","createObjectStore","transaction","createMutableFile","File","Blob","remove","delete","list","options","allKeys","getAllKeys","filteredKeys","filter","key","match","startsWith","endsWith","includes","filterFn","count","length","type","clear"],"mappings":"4QAAA,aAmCO,QAASA,kBAAT,CAA2BC,GAA3B,CAAgCC,SAAhC,CAA2C,CAChD,MAAO,IAAIC,QAAJ,CAAY,CAACC,OAAD,CAAUC,MAAV,GAAqB,CACtCJ,IAAIC,SAAJ,CAAgBA,UACb,IAAME,QAAQF,UAAUD,IAAIK,MAAd,CAAR,CADO,CAC4B,IAAMF,QAAQH,IAAIK,MAAZ,CAFZ,CAGtCL,IAAIM,OAAJ,CAAc,IAAMF,OAAOJ,IAAIO,KAAX,CACrB,CAJM,CAKR,C,+DANeR,iB,CAAAA,iB,SAqtBMS,c,CAAf,eAA8B,CAACC,IAAD,CAAOC,UAAP,IAA9B,CAAuD,CAC5D,KAAMC,cAAe,GAAIC,eAAJ,CAAmB,CAACH,KAAMA,MAAQ,SAAf,CAA0BC,UAA1B,CAAnB,CAArB,CAEA,MADA,MAAMC,cAAaE,aAAb,EACN,CAAOF,YACR,C,CA3sBM,KAAMG,sBAAsB,CAIjCC,YAAY,CAACC,IAAD,CAAOC,UAAP,CAAZ,CAAgC,CAK9B,KAAKD,IAAL,CAAYA,IALkB,CAO9B,KAAKC,UAAL,CAAkBA,UAPY,CAS9B,KAAKC,UAAL,CAAkBhB,QAAQC,OAAR,EATY,CAW9B,KAAKgB,MAAL,OAX8B,CAa9B,KAAKC,OAAL,OACD,CAKDC,aAAa,CAACC,WAAD,IAAb,CAAiC,CAC/B,GAAI,KAAKH,MAAT,CACE,KAAM,IAAII,MAAJ,CAAU,4BAAV,CAAN,CAGF,GAAI,KAAKH,OAAT,CACE,KAAM,IAAIG,MAAJ,CAAU,6BAAV,CAAN,CAGF,GAAI,CAAC,KAAKN,UAAV,CACE,KAAM,IAAIM,MAAJ,CAAU,qBAAV,CAAN,CAGF,GAAID,aAAe,KAAKL,UAAL,CAAgBO,IAAhB,GAAyBF,WAA5C,CACE,KAAM,IAAIC,MAAJ,CAAW,uCAAsC,KAAKN,UAAL,CAAgBO,IAAK,GAAtE,CAAN,CAEG,KAAKP,UAAL,CAAgBQ,MAhBU,EAkB7B,KAAKT,IAAL,CAAUU,gBAAV,CAA2B,IAA3B,CAEH,CASD,GAAIF,KAAJ,EAAW,CACT,MAAO,MAAKP,UAAL,CAAgBO,IACxB,CAOD,GAAIC,OAAJ,EAAa,CACX,QAAO,KAAKR,UAAZ,EAAyB,KAAKA,UAAL,CAAgBQ,MAC1C,CAQD,KAAME,MAAN,EAAc,CACZ,GAAI,CAAC,KAAKV,UAAV,CACE,KAAM,IAAIM,MAAJ,CAAU,wBAAV,CAAN,CAIF,KAAM,MAAKL,UANC,CASR,KAAKD,UAAL,CAAgBQ,MAAhB,EAAmD,UAAzB,QAAKR,UAAL,CAAgBO,IATlC,GAUV,KAAMzB,mBAAkB,KAAKkB,UAAL,CAAgBW,KAAhB,EAAlB,CAVI,EAaZ,KAAKT,MAAL,GAbY,CAcZ,KAAKF,UAAL,CAAkB,IAdN,CAeZ,KAAKC,UAAL,CAAkBhB,QAAQC,OAAR,EACnB,CAQD,KAAM0B,MAAN,EAAc,CACR,KAAKZ,UAAL,CAAgBQ,MADR,EAIV,KAAKR,UAAL,CAAgBY,KAAhB,EAJU,CAOZ,KAAKT,OAAL,GAPY,CAQZ,KAAKH,UAAL,CAAkB,IARN,CASZ,KAAKC,UAAL,CAAkBhB,QAAQC,OAAR,EACnB,CAQD,KAAM2B,YAAN,EAAoB,CAElB,MADA,MAAKT,YAAL,EACA,CAAOtB,kBAAkB,KAAKkB,UAAL,CAAgBa,WAAhB,EAAlB,CACR,CAcD,KAAMC,WAAN,CAAiBC,IAAjB,CAAuBC,QAAvB,CAAiC,CAK/B,MAJA,MAAKZ,YAAL,CAAkB,CAACC,YAAa,WAAd,CAAlB,CAIA,CAHwB,QAApB,QAAOW,SAGX,GAFE,KAAKhB,UAAL,CAAgBgB,QAAhB,CAA2BA,QAE7B,EAAOlC,kBAAkB,KAAKkB,UAAL,CAAgBc,UAAhB,CAA2BC,IAA3B,CAAlB,CACR,CAcD,KAAME,kBAAN,CAAwBF,IAAxB,CAA8BC,QAA9B,CAAwC,CAKtC,MAJA,MAAKZ,YAAL,CAAkB,CAACC,YAAa,WAAd,CAAlB,CAIA,CAHwB,QAApB,QAAOW,SAGX,GAFE,KAAKhB,UAAL,CAAgBgB,QAAhB,CAA2BA,QAE7B,EAAOlC,kBAAkB,KAAKkB,UAAL,CAAgBiB,iBAAhB,CAAkCF,IAAlC,CAAlB,CACR,CAWD,KAAMG,SAAN,CAAeF,SAAW,CAA1B,CAA6B,CAE3B,MADA,MAAKZ,YAAL,CAAkB,CAACC,YAAa,UAAd,CAAlB,CACA,CAAOvB,kBAAkB,KAAKkB,UAAL,CAAgBkB,QAAhB,CAAyBF,QAAzB,CAAlB,CACR,CAWD,KAAMG,OAAN,CAAaC,IAAb,CAAmB,CAEjB,MADA,MAAKhB,YAAL,CAAkB,CAACC,YAAa,UAAd,CAAlB,CACA,CAAOvB,kBAAkB,KAAKkB,UAAL,CAAgBmB,MAAhB,CAAuBC,IAAvB,CAAlB,CACR,CAaD,KAAMC,MAAN,CAAYD,IAAZ,CAAkBJ,QAAlB,CAA4B,CAK1B,MAJA,MAAKZ,YAAL,CAAkB,CAACC,YAAa,UAAd,CAAlB,CAIA,CAHwB,QAApB,QAAOW,SAGX,GAFE,KAAKhB,UAAL,CAAgBgB,QAAhB,CAA2BA,QAE7B,EAAOlC,kBACL,KAAKkB,UAAL,CAAgBqB,KAAhB,CAAsBD,IAAtB,CADK,CAGL,IAAM,CACJ,MAAO,MAAKpB,UAAL,CAAgBgB,QACxB,CALI,CAOR,CAeDM,YAAYF,IAAZ,CAAkBJ,QAAlB,CAA4B,CAW1B,MADA,MAAKf,UAAL,CAAkB,KAAKA,UAAL,CAAgBsB,IAAhB,CATO,KAAMC,aAAN,EAAsB,OAC7C,MAAKpB,YAAL,CAAkB,CAACC,YAAa,UAAd,CAAlB,CAD6C,CAGrB,QAApB,QAAOW,SAHkC,CAIpC,KAAKK,KAAL,CAAWD,IAAX,CAAiBJ,QAAjB,CAJoC,CAMtC,KAAKK,KAAL,CAAWD,IAAX,CAAiBI,YAAjB,CACR,CAEiB,CAClB,CAAO,KAAKvB,UACb,CASD,KAAMwB,oBAAN,EAA4B,CAC1B,KAAM,MAAKxB,UACZ,CAvPgC,C,QAAtBJ,qB,CAAAA,qB,CAgQN,KAAM6B,uBAAuB,CAIlC5B,YAAY,CAACJ,YAAD,CAAeiC,GAAf,CAAoBC,QAApB,CAA8BC,QAA9B,CAAwCC,WAAxC,CAAZ,CAAkE,CAKhE,KAAKpC,YAAL,CAAoBA,YAL4C,CAOhE,KAAKiC,GAAL,CAAWA,GAPqD,CAShE,KAAKC,QAAL,CAAgBA,QATgD,CAWhE,KAAKC,QAAL,CAAgBA,QAXgD,CAahE,KAAKC,WAAL,CAAmBA,WACpB,CAKDrB,iBAAiBsB,UAAjB,CAA6B,CAC3BA,WAAW/B,UAAX,CAAwB,KAAK8B,WAAL,CAAiBE,IAAjB,CAAsBD,WAAWxB,IAAjC,CACzB,CAaDyB,KAAKzB,IAAL,CAAW,CACT,GAAI,KAAKP,UAAT,CACE,KAAM,IAAIM,MAAJ,CAAU,oCAAV,CAAN,CAEF,KAAMN,YAAa,KAAK8B,WAAL,CAAiBE,IAAjB,CAAsBzB,IAAtB,CAAnB,CAEA,MAAO,IAAIV,sBAAJ,CAA0B,CAACE,KAAM,IAAP,CAAaC,UAAb,CAA1B,CACR,CAkCDiC,SAAU,CACR,MAAOnD,mBAAkB,KAAKgD,WAAL,CAAiBG,OAAjB,EAAlB,CACR,CAgBD,KAAMC,sBAAN,CAA4BC,YAA5B,CAA0C,CACxC,GAAIA,eAAiB,KAAKP,QAA1B,CACE,KAAM,IAAItB,MAAJ,CAAU,qDAAV,CAAN,CAGF,KAAMqB,KAAM,KAAM,MAAKjC,YAAL,CAAkBE,aAAlB,EAAlB,CAQA,MAPA,MAAM,MAAKwC,uBAAL,CAA6B,WAAa,CAC9C,KAAMrC,MAAO,KAAM,MAAK+B,WAAL,CAAiBG,OAAjB,EAAnB,CACMI,YAAc,KAAK3C,YAAL,CAAkB4C,yBAAlB,CAA4C,CAACX,GAAD,CAAMpB,KAAM,WAAZ,CAA5C,CADpB,CAGA,KAAM8B,aAAYE,GAAZ,CAAgBxC,IAAhB,CAAsBoC,YAAtB,CACP,CALkC,CAKjCK,IALiC,CAK5B,IAL4B,CAA7B,CAON,CAAO,KAAK9C,YAAL,CAAkB+C,GAAlB,CAAsBN,YAAtB,CACR,CAQDO,SAAU,CACR,MAAO,MAAKhD,YAAL,CAAkB6C,GAAlB,CAAsB,KAAKX,QAA3B,CAAqC,IAArC,CACR,CAkCD,KAAMQ,wBAAN,CAA8BO,iBAA9B,CAAiDpC,IAAjD,CAAuD,CACrD,GAA2C,mBAAvC,qBAAkBT,WAAlB,CAA8BN,IAAlC,CACE,KAAM,IAAIc,MAAJ,CAAU,uDAAV,CAAN,CAGF,KAAM,IAAIrB,QAAJ,CAAY,CAACC,OAAD,CAAUC,MAAV,GAAqB,CACrC,KAAMa,YAAa,KAAK8B,WAAL,CAAiBE,IAAjB,CAAsBzB,MAAQ,WAA9B,CAAnB,CACMqC,iBAAmBD,kBAAkB3C,UAAlB,CADzB,CAGM6C,uBAAyBC,mBAAqB,CAClD,KAAMC,iBAAkBH,iBAAiBI,IAAjB,CAAsBF,iBAAtB,CAAxB,CACA,GAAIC,gBAAgBE,IAApB,CAEE,WADA/D,UACA,CACK,GAAI,EAAE6D,gBAAgBG,KAAhB,WAAiCC,QAAOC,UAAxC,EACAL,gBAAgBG,KAAhB,WAAiCC,QAAOE,UAD1C,CAAJ,CAC2D,CAChE,KAAM/D,OAAQ,GAAIgB,MAAJ,CAAU,6DAAV,CAAd,CAGA,MAFAsC,kBAAiBU,KAAjB,CAAuBhE,KAAvB,CAEA,KADAH,QAAOG,KAAP,CAED,CAED,KAAMiE,SAAUR,gBAAgBG,KAAhC,CACA,GAAIK,QAAQvE,SAAR,EAAqBuE,QAAQlE,OAAjC,CAA0C,CACxC,KAAMC,OAAQ,GAAIgB,MAAJ,CAAU,wDAAV,CAAd,CACAsC,iBAAiBU,KAAjB,CAAuBhE,KAAvB,CAFwC,CAGxCH,OAAOG,KAAP,CACD,CAJD,IAKEiE,SAAQvE,SAAR,CAAoB,IAAM6D,uBAAuBU,QAAQnE,MAA/B,CAL5B,CAMEmE,QAAQlE,OAAR,CAAkB,IAAMF,OAAOoE,QAAQjE,KAAf,CAE3B,CAzBD,CA2BAuD,wBACD,CA7BK,CA8BP,CA9LiC,C,QAAvBnB,sB,CAAAA,sB,CAuMN,KAAM/B,eAAe,CAI1BG,YAAY,CAACN,IAAD,CAAOC,UAAP,IAAZ,CAAqC,CAKnC,KAAKD,IAAL,CAAYA,IALuB,CAOnC,KAAKC,UAAL,CAAkBA,UAPiB,CASnC,KAAK+D,aAAL,CAAsB,sBAAqB,KAAKhE,IAAK,EATlB,CAWnC,KAAKiE,iBAAL,CAAyB,uBAXU,CAanC,KAAKC,kBAAL,OAbmC,CAiBnC,KAAKC,OAAL,EACD,CAKD/D,eAAgB,OACV,MAAK8D,kBADK,CAEL,KAAKA,kBAFA,EAKd,KAAKA,kBAAL,CAA0B,CAAC,SAAY,CACjCP,OAAOS,cAAP,EAAyB,KAAKnE,UADG,GAEnC,KAAKkE,OAAL,CAAe,CAACA,QAAS,KAAKA,OAAf,CAAwBE,QAAS,YAAjC,CAFoB,EAIrC,KAAMC,OAAQC,UAAU/B,IAAV,CAAe,KAAKwB,aAApB,CAAmC,KAAKG,OAAxC,CAAd,CASA,MAPAG,OAAME,eAAN,CAAwB,IAAM,CAC5B,KAAMC,IAAKH,MAAM1E,MAAjB,CACK6E,GAAGC,gBAAH,CAAoBC,QAApB,CAA6B,KAAKV,iBAAlC,CAFuB,EAG1BQ,GAAGG,iBAAH,CAAqB,KAAKX,iBAA1B,CAEH,CAED,CAAO3E,kBAAkBgF,KAAlB,CACR,CAdyB,GALZ,CAqBP,KAAKJ,kBArBE,CAsBf,CAKDpB,0BAA0B,CAACX,GAAD,CAAMpB,IAAN,IAA1B,CAA4C,CAC1C,KAAM8D,aAAc1C,IAAI0C,WAAJ,CAAgB,CAAC,KAAKZ,iBAAN,CAAhB,CAA0ClD,IAA1C,CAApB,CACA,MAAO8D,aAAYhC,WAAZ,CAAwB,KAAKoB,iBAA7B,CACR,CAaD,KAAMa,kBAAN,CAAwB1C,QAAxB,CAAkCC,SAAW,MAA7C,CAAqD,CACnD,GAAI,CAACsB,OAAOS,cAAZ,CACE,KAAM,IAAItD,MAAJ,CAAU,kDAAV,CAAN,CAEF,KAAMqB,KAAM,KAAM,MAAK/B,aAAL,EAAlB,CACMkC,YAAc,KAAMhD,mBACxB6C,IAAI2C,iBAAJ,CAAsB1C,QAAtB,CAAgCC,QAAhC,CADwB,CAD1B,CAIA,MAAO,IAAIH,uBAAJ,CAA2B,CAChChC,aAAc,IADkB,CACZiC,GADY,CACPC,QADO,CACGC,QADH,CACaC,WADb,CAA3B,CAGR,CAcD,KAAMS,IAAN,CAAUX,QAAV,CAAoB7B,IAApB,CAA0B,CACxB,GAAI,CAAC6B,QAAD,EAAiC,QAApB,QAAOA,SAAxB,CACE,KAAM,IAAItB,MAAJ,CAAU,iCAAV,CAAN,CAGF,GAAI,EAAEP,eAAgBwE,KAAlB,GAA2B,EAAExE,eAAgByE,KAAlB,CAA3B,EACA,EAAErB,OAAOS,cAAP,EAAyB7D,eAAgBoD,QAAOS,cAAlD,CADA,EAEA,EAAE7D,eAAgB2B,uBAAlB,CAFJ,CAGE,KAAM,IAAIpB,MAAJ,CAAW,qBAAoBsB,QAAS,sBAAxC,CAAN,CAGE7B,eAAgB2B,uBAXI,GAYtB3B,KAAOA,KAAK+B,WAZU,EAexB,KAAMH,KAAM,KAAM,MAAK/B,aAAL,EAAlB,CACMyC,YAAc,KAAKC,yBAAL,CAA+B,CAACX,GAAD,CAAMpB,KAAM,WAAZ,CAA/B,CADpB,CAEA,MAAOzB,mBAAkBuD,YAAYE,GAAZ,CAAgBxC,IAAhB,CAAsB6B,QAAtB,CAAlB,CACR,CAWD,KAAM6C,OAAN,CAAa7C,QAAb,CAAuB,CACrB,GAAI,CAACA,QAAL,CACE,KAAM,IAAItB,MAAJ,CAAU,iCAAV,CAAN,CAGF,KAAMqB,KAAM,KAAM,MAAK/B,aAAL,EAAlB,CACMyC,YAAc,KAAKC,yBAAL,CAA+B,CAACX,GAAD,CAAMpB,KAAM,WAAZ,CAA/B,CADpB,CAEA,MAAOzB,mBAAkBuD,YAAYqC,MAAZ,CAAmB9C,QAAnB,CAAlB,CACR,CAcD,KAAM+C,KAAN,CAAWC,OAAX,CAAoB,CAClB,KAAMjD,KAAM,KAAM,MAAK/B,aAAL,EAAlB,CACMyC,YAAc,KAAKC,yBAAL,CAA+B,CAACX,GAAD,CAA/B,CADpB,CAEMkD,QAAU,KAAM/F,mBAAkBuD,YAAYyC,UAAZ,EAAlB,CAFtB,CAIA,GAAIC,cAAeF,OAAnB,CA0BA,MAxBID,QAwBJ,GAvBEG,aAAeA,aAAaC,MAAb,CAAoBC,KAAO,CACxC,GAAIC,SAAJ,CAkBA,MAhBkC,QAA9B,QAAON,SAAQO,UAgBnB,GAfED,MAAQA,OAASD,IAAIE,UAAJ,CAAeP,QAAQO,UAAvB,CAenB,EAZgC,QAA5B,QAAOP,SAAQQ,QAYnB,GAXEF,MAAQA,OAASD,IAAIG,QAAJ,CAAaR,QAAQQ,QAArB,CAWnB,EARgC,QAA5B,QAAOR,SAAQS,QAQnB,GAPEH,MAAQA,OAASD,IAAII,QAAJ,CAAaT,QAAQS,QAArB,CAOnB,EAJgC,UAA5B,QAAOT,SAAQU,QAInB,GAHEJ,MAAQA,OAASN,QAAQU,QAAR,CAAiBL,GAAjB,CAGnB,EAAOC,KACR,CApBc,CAuBjB,EAAOH,YACR,CAcD,KAAMQ,MAAN,CAAYX,OAAZ,CAAqB,CACnB,GAAI,CAACA,OAAL,CAAc,CACZ,KAAMjD,KAAM,KAAM,MAAK/B,aAAL,EAAlB,CACMyC,YAAc,KAAKC,yBAAL,CAA+B,CAACX,GAAD,CAA/B,CADpB,CAEA,MAAO7C,mBAAkBuD,YAAYkD,KAAZ,EAAlB,CACR,CAED,KAAMR,cAAe,KAAM,MAAKJ,IAAL,CAAUC,OAAV,CAA3B,CACA,MAAOG,cAAaS,MACrB,CAWD,KAAM/C,IAAN,CAAUb,QAAV,CAAoB,CAClB,KAAMD,KAAM,KAAM,MAAK/B,aAAL,EAAlB,CACMyC,YAAc,KAAKC,yBAAL,CAA+B,CAACX,GAAD,CAA/B,CADpB,CAEA,MAAO7C,mBAAkBuD,YAAYI,GAAZ,CAAgBb,QAAhB,CAAlB,EAA6CL,IAA7C,CAAkDnC,QAAU,OAC7D+D,QAAOS,cAAP,EAAyBxE,iBAAkB+D,QAAOS,cADW,CAExD,GAAIlC,uBAAJ,CAA2B,CAChChC,aAAc,IADkB,CAEhCiC,GAFgC,CAGhCC,QAHgC,CAIhCC,SAAUzC,OAAOqG,IAJe,CAKhC3D,YAAa1C,MALmB,CAA3B,CAFwD,CAW1DA,MACR,CAZM,CAaR,CAQD,KAAMsG,MAAN,EAAc,CACZ,KAAM/D,KAAM,KAAM,MAAK/B,aAAL,EAAlB,CACMyC,YAAc,KAAKC,yBAAL,CAA+B,CAACX,GAAD,CAAMpB,KAAM,WAAZ,CAA/B,CADpB,CAEA,MAAOzB,mBAAkBuD,YAAYqD,KAAZ,EAAlB,CACR,CAhPyB,C,QAAf/F,c,CAAAA,c","file":"idb-file-storage.min.js","sourcesContent":["\"use strict\";\n\n/**\n * @typedef {Object} IDBPromisedFileHandle.Metadata\n * @property {number} size\n *   The size of the file in bytes.\n * @property {Date} last Modified\n *   The time and date of the last change to the file.\n */\n\n/**\n * @typedef {Object} IDBFileStorage.ListFilteringOptions\n * @property {string} startsWith\n *   A string to be checked with `fileNameString.startsWith(...)`.\n * @property {string} endsWith\n *   A string to be checked with  `fileNameString.endsWith(...)`.\n * @property {string} includes\n *   A string to be checked with `fileNameString.includes(...)`.\n * @property {function} filterFn\n *   A function to be used to check the file name (`filterFn(fileNameString)`).\n */\n\n/**\n * Wraps a DOMRequest into a promise, optionally transforming the result using the onsuccess\n * callback.\n *\n * @param {IDBRequest|DOMRequest} req\n *   The DOMRequest instance to wrap in a Promise.\n * @param {function}  [onsuccess]\n *   An optional onsuccess callback which can transform the result before resolving it.\n *\n * @returns {Promise}\n *   The promise which wraps the request result, rejected if the request.onerror has been\n *   called.\n */\nexport function waitForDOMRequest(req, onsuccess) {\n  return new Promise((resolve, reject) => {\n    req.onsuccess = onsuccess ?\n      (() => resolve(onsuccess(req.result))) : (() => resolve(req.result));\n    req.onerror = () => reject(req.error);\n  });\n}\n\n/**\n * Wraps an IDBMutableFile's FileHandle with a nicer Promise-based API.\n *\n * Instances of this class are created from the\n * {@link IDBPromisedMutableFile.open} method.\n */\nexport class IDBPromisedFileHandle {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({file, lockedFile}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.file = file;\n    /** @private */\n    this.lockedFile = lockedFile;\n    /** @private */\n    this.writeQueue = Promise.resolve();\n    /** @private */\n    this.closed = undefined;\n    /** @private */\n    this.aborted = undefined;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  ensureLocked({invalidMode} = {}) {\n    if (this.closed) {\n      throw new Error(\"FileHandle has been closed\");\n    }\n\n    if (this.aborted) {\n      throw new Error(\"FileHandle has been aborted\");\n    }\n\n    if (!this.lockedFile) {\n      throw new Error(\"Invalid FileHandled\");\n    }\n\n    if (invalidMode && this.lockedFile.mode === invalidMode) {\n      throw new Error(`FileHandle should not be opened as '${this.lockedFile.mode}'`);\n    }\n    if (!this.lockedFile.active) {\n      // Automatically relock the file with the last open mode\n      this.file.reopenFileHandle(this);\n    }\n  }\n\n  // Promise-based MutableFile API\n\n  /**\n   * Provide access to the mode that has been used to open the {@link IDBPromisedMutableFile}.\n   *\n   * @type {\"readonly\"|\"readwrite\"|\"writeonly\"}\n   */\n  get mode() {\n    return this.lockedFile.mode;\n  }\n\n  /**\n   * A boolean property that is true if the lock is still active.\n   *\n   * @type {boolean}\n   */\n  get active() {\n    return this.lockedFile ? this.lockedFile.active : false;\n  }\n\n  /**\n   * Close the locked file (and wait for any written data to be flushed if needed).\n   *\n   * @returns {Promise}\n   *   A promise which is resolved when the close request has been completed\n   */\n  async close() {\n    if (!this.lockedFile) {\n      throw new Error(\"FileHandle is not open\");\n    }\n\n    // Wait the queued write to complete.\n    await this.writeQueue;\n\n    // Wait for flush request to complete if needed.\n    if (this.lockedFile.active && this.lockedFile.mode !== \"readonly\") {\n      await waitForDOMRequest(this.lockedFile.flush());\n    }\n\n    this.closed = true;\n    this.lockedFile = null;\n    this.writeQueue = Promise.resolve();\n  }\n\n  /**\n   * Abort any pending data request and set the instance as aborted.\n   *\n   * @returns {Promise}\n   *   A promise which is resolved when the abort request has been completed\n   */\n  async abort() {\n    if (this.lockedFile.active) {\n      // NOTE: in the docs abort is reported to return a DOMRequest, but it doesn't seem\n      // to be the case. (https://developer.mozilla.org/en-US/docs/Web/API/LockedFile/abort)\n      this.lockedFile.abort();\n    }\n\n    this.aborted = true;\n    this.lockedFile = null;\n    this.writeQueue = Promise.resolve();\n  }\n\n  /**\n   * Get the file metadata (take a look to {@link IDBPromisedFileHandle.Metadata} for more info).\n   *\n   * @returns {Promise<{size: number, lastModified: Date}>}\n   *   A promise which is resolved when the request has been completed\n   */\n  async getMetadata() {\n    this.ensureLocked();\n    return waitForDOMRequest(this.lockedFile.getMetadata());\n  }\n\n  /**\n   * Read a given amount of data from the file as Text (optionally starting from the specified\n   * location).\n   *\n   * @param {number} size\n   *   The amount of data to read.\n   * @param {number} [location]\n   *   The location where the request should start to read the data.\n   *\n   * @returns {Promise<string>}\n   *   A promise which resolves to the data read, when the request has been completed.\n   */\n  async readAsText(size, location) {\n    this.ensureLocked({invalidMode: \"writeonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(this.lockedFile.readAsText(size));\n  }\n\n  /**\n   * Read a given amount of data from the file as an ArrayBufer (optionally starting from the specified\n   * location).\n   *\n   * @param {number} size\n   *   The amount of data to read.\n   * @param {number} [location]\n   *   The location where the request should start to read the data.\n   *\n   * @returns {Promise<ArrayBuffer>}\n   *   A promise which resolves to the data read, when the request has been completed.\n   */\n  async readAsArrayBuffer(size, location) {\n    this.ensureLocked({invalidMode: \"writeonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(this.lockedFile.readAsArrayBuffer(size));\n  }\n\n  /**\n   * Truncate the file (optionally at a specified location).\n   *\n   * @param {number} [location=0]\n   *   The location where the file should be truncated.\n   *\n   * @returns {Promise<ArrayBuffer>}\n   *   A promise which is resolved once the request has been completed.\n   */\n  async truncate(location = 0) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    return waitForDOMRequest(this.lockedFile.truncate(location));\n  }\n\n  /**\n   * Append the passed data to the end of the file.\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to append to the end of the file.\n   *\n   * @returns {Promise}\n   *   A promise which is resolved once the request has been completed.\n   */\n  async append(data) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    return waitForDOMRequest(this.lockedFile.append(data));\n  }\n\n  /**\n   * Write data into the file (optionally starting from a defined location in the file).\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to write into the file.\n   * @param {number} location\n   *   The location where the data should be written.\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved to the location where the written data ends.\n   */\n  async write(data, location) {\n    this.ensureLocked({invalidMode: \"readonly\"});\n    if (typeof location === \"number\") {\n      this.lockedFile.location = location;\n    }\n    return waitForDOMRequest(\n      this.lockedFile.write(data),\n      // Resolves to the new location.\n      () => {\n        return this.lockedFile.location;\n      }\n    );\n  }\n\n  /**\n   * Queue data to be written into the file (optionally starting from a defined location in the file).\n   *\n   * @param {string|ArrayBuffer} data\n   *   The data to write into the file.\n   * @param {number} location\n   *   The location where the data should be written (when not specified the end of the previous\n   *   queued write is used).\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved once the request has been completed with the location where the\n   *   file was after the data has been writted.\n   */\n  queuedWrite(data, location) {\n    const nextWriteRequest = async lastLocation => {\n      this.ensureLocked({invalidMode: \"readonly\"});\n\n      if (typeof location === \"number\") {\n        return this.write(data, location);\n      }\n      return this.write(data, lastLocation);\n    };\n\n    this.writeQueue = this.writeQueue.then(nextWriteRequest);\n    return this.writeQueue;\n  }\n\n  /**\n   * Wait that any queued data has been written.\n   *\n   * @returns {Promise<number>}\n   *   A promise which is resolved once the request has been completed with the location where the\n   *   file was after the data has been writted.\n   */\n  async waitForQueuedWrites() {\n    await this.writeQueue;\n  }\n}\n\n/**\n * Wraps an IDBMutableFile with a nicer Promise-based API.\n *\n * Instances of this class are created from the\n * {@link IDBFileStorage.createMutableFile} method.\n */\nexport class IDBPromisedMutableFile {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({filesStorage, idb, fileName, fileType, mutableFile}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.filesStorage = filesStorage;\n    /** @private */\n    this.idb = idb;\n    /** @private */\n    this.fileName = fileName;\n    /** @private */\n    this.fileType = fileType;\n    /** @private */\n    this.mutableFile = mutableFile;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  reopenFileHandle(fileHandle) {\n    fileHandle.lockedFile = this.mutableFile.open(fileHandle.mode);\n  }\n\n  // API methods.\n\n  /**\n   * Open a mutable file for reading/writing data.\n   *\n   * @param {\"readonly\"|\"readwrite\"|\"writeonly\"} mode\n   *   The mode of the created IDBPromisedFileHandle instance.\n   *\n   * @returns {IDBPromisedFileHandle}\n   *   The created IDBPromisedFileHandle instance.\n   */\n  open(mode) {\n    if (this.lockedFile) {\n      throw new Error(\"MutableFile cannot be opened twice\");\n    }\n    const lockedFile = this.mutableFile.open(mode);\n\n    return new IDBPromisedFileHandle({file: this, lockedFile});\n  }\n\n  /**\n   * Get a {@link File} instance of this mutable file.\n   *\n   * @returns {Promise<File>}\n   *   A promise resolved to the File instance.\n   *\n   * To read the actual content of the mutable file as a File object,\n   * it is often better to use {@link IDBPromisedMutableFile.saveAsFileSnapshot}\n   * to save a persistent snapshot of the file in the IndexedDB store,\n   * or reading it directly using the {@link IDBPromisedFileHandle} instance\n   * returned by the {@link IDBPromisedMutableFile.open} method.\n   *\n   * The reason is that to be able to read the content of the returned file\n   * a lockfile have be keep the file open, e.d. as in the following example.\n   *\n   * @example\n   *     ...\n   *     let waitSnapshotStored;\n   *     await mutableFile.runFileRequestGenerator(function* (lockedFile) {\n   *       const file = yield lockedFile.mutableFile.getFile();\n   *       // read the file content or turn it into a persistent object of its own\n   *       // (e.g. by saving it back into IndexedDB as its snapshot in form of a File object,\n   *       // or converted into a data url, a string or an array buffer)\n   *\n   *       waitSnapshotStored = tmpFiles.put(\"${filename}/last_snapshot\", file);\n   *     }\n   *\n   *     await waitSnapshotStored;\n   *     let fileSnapshot = await tmpFiles.get(\"${filename}/last_snapshot\");\n   *     ...\n   *     // now you can use fileSnapshot even if the mutableFile lock is not active anymore.\n   */\n  getFile() {\n    return waitForDOMRequest(this.mutableFile.getFile());\n  }\n\n  /**\n   * Persist the content of the mutable file into the files storage\n   * as a File, using the specified snapshot name and return the persisted File instance.\n   *\n   * @returns {Promise<File>}\n   *   A promise resolved to the File instance.\n   *\n   * @example\n   *\n   *      const file = await mutableFile.persistAsFileSnapshot(`${filename}/last_snapshot`);\n   *      const blobURL = URL.createObjectURL(file);\n   *      ...\n   *      // The blob URL is still valid even if the mutableFile is not active anymore.\n   */\n  async persistAsFileSnapshot(snapshotName) {\n    if (snapshotName === this.fileName) {\n      throw new Error(\"Snapshot name and the file name should be different\");\n    }\n\n    const idb = await this.filesStorage.initializedDB();\n    await this.runFileRequestGenerator(function* () {\n      const file = yield this.mutableFile.getFile();\n      const objectStore = this.filesStorage.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n\n      yield objectStore.put(file, snapshotName);\n    }.bind(this));\n\n    return this.filesStorage.get(snapshotName);\n  }\n\n  /**\n   * Persist the this mutable file into its related IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved on the mutable file has been persisted into IndexedDB.\n   */\n  persist() {\n    return this.filesStorage.put(this.fileName, this);\n  }\n\n  /**\n   * Run a generator function which can run a sequence of FileRequests\n   * without the lockfile to become inactive.\n   *\n   * This method should be rarely needed, mostly to optimize a sequence of\n   * file operations without the file to be closed and automatically re-opened\n   * between two file requests.\n   *\n   * @param {function* (lockedFile) {...}} generatorFunction\n   * @param {\"readonly\"|\"readwrite\"|\"writeonly\"} mode\n   *\n   * @example\n   *   (async function () {\n   *      const tmpFiles = await IDBFiles.getFileStorage({name: \"tmpFiles\"});\n   *      const mutableFile = await tmpFiles.createMutableFile(\"test-mutable-file.txt\");\n   *\n   *      let allFileData;\n   *\n   *      function* fileOperations(lockedFile) {\n   *        yield lockedFile.write(\"some data\");\n   *        yield lockedFile.write(\"more data\");\n   *        const metadata = yield lockedFile.getMetadata();\n   *\n   *        lockedFile.location = 0;\n   *        allFileData = yield lockedFile.readAsText(metadata.size);\n   *      }\n   *\n   *      await mutableFile.runFileRequestGenerator(fileOperations, \"readwrite\");\n   *\n   *      console.log(\"File Data\", allFileData);\n   *   })();\n   */\n  async runFileRequestGenerator(generatorFunction, mode) {\n    if (generatorFunction.constructor.name !== \"GeneratorFunction\") {\n      throw new Error(\"runGenerator parameter should be a generator function\");\n    }\n\n    await new Promise((resolve, reject) => {\n      const lockedFile = this.mutableFile.open(mode || \"readwrite\");\n      const fileRequestsIter = generatorFunction(lockedFile);\n\n      const processFileRequestIter = prevRequestResult => {\n        const nextFileRequest = fileRequestsIter.next(prevRequestResult);\n        if (nextFileRequest.done) {\n          resolve();\n          return;\n        } else if (!(nextFileRequest.value instanceof window.DOMRequest ||\n                     nextFileRequest.value instanceof window.IDBRequest)) {\n          const error = new Error(\"FileRequestGenerator should only yield DOMRequest instances\");\n          fileRequestsIter.throw(error);\n          reject(error);\n          return;\n        }\n\n        const request = nextFileRequest.value;\n        if (request.onsuccess || request.onerror) {\n          const error = new Error(\"DOMRequest onsuccess/onerror callbacks are already set\");\n          fileRequestsIter.throw(error);\n          reject(error);\n        } else {\n          request.onsuccess = () => processFileRequestIter(request.result);\n          request.onerror = () => reject(request.error);\n        }\n      };\n\n      processFileRequestIter();\n    });\n  }\n}\n\n/**\n * Provides a Promise-based API to store files into an IndexedDB.\n *\n * Instances of this class are created using the exported\n * {@link getFileStorage} function.\n */\nexport class IDBFileStorage {\n  /**\n   * @private private helper method used internally.\n   */\n  constructor({name, persistent} = {}) {\n    // All the following properties are private and it should not be needed\n    // while using the API.\n\n    /** @private */\n    this.name = name;\n    /** @private */\n    this.persistent = persistent;\n    /** @private */\n    this.indexedDBName = `IDBFilesStorage-DB-${this.name}`;\n    /** @private */\n    this.objectStorageName = \"IDBFilesObjectStorage\";\n    /** @private */\n    this.initializedPromise = undefined;\n\n    // TODO: evalutate schema migration between library versions?\n    /** @private */\n    this.version = 1.0;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  initializedDB() {\n    if (this.initializedPromise) {\n      return this.initializedPromise;\n    }\n\n    this.initializedPromise = (async () => {\n      if (window.IDBMutableFile && this.persistent) {\n        this.version = {version: this.version, storage: \"persistent\"};\n      }\n      const dbReq = indexedDB.open(this.indexedDBName, this.version);\n\n      dbReq.onupgradeneeded = () => {\n        const db = dbReq.result;\n        if (!db.objectStoreNames.contains(this.objectStorageName)) {\n          db.createObjectStore(this.objectStorageName);\n        }\n      };\n\n      return waitForDOMRequest(dbReq);\n    })();\n\n    return this.initializedPromise;\n  }\n\n  /**\n   * @private private helper method used internally.\n   */\n  getObjectStoreTransaction({idb, mode} = {}) {\n    const transaction = idb.transaction([this.objectStorageName], mode);\n    return transaction.objectStore(this.objectStorageName);\n  }\n\n  /**\n   * Create a new IDBPromisedMutableFile instance (where the IDBMutableFile is supported)\n   *\n   * @param {string} fileName\n   *   The fileName associated to the new IDBPromisedMutableFile instance.\n   * @param {string} [fileType=\"text\"]\n   *   The mime type associated to the file.\n   *\n   * @returns {IDBPromisedMutableFile}\n   *   The newly created {@link IDBPromisedMutableFile} instance.\n   */\n  async createMutableFile(fileName, fileType = \"text\") {\n    if (!window.IDBMutableFile) {\n      throw new Error(\"This environment does not support IDBMutableFile\");\n    }\n    const idb = await this.initializedDB();\n    const mutableFile = await waitForDOMRequest(\n      idb.createMutableFile(fileName, fileType)\n    );\n    return new IDBPromisedMutableFile({\n      filesStorage: this, idb, fileName, fileType, mutableFile\n    });\n  }\n\n  /**\n   * Put a file object into the IDBFileStorage, it overwrites an existent file saved with the\n   * fileName if any.\n   *\n   * @param {string} fileName\n   *   The key associated to the file in the IDBFileStorage.\n   * @param {Blob|File|IDBPromisedMutableFile|IDBMutableFile} file\n   *   The file to be persisted.\n   *\n   * @returns {Promise}\n   *   A promise resolved when the request has been completed.\n   */\n  async put(fileName, file) {\n    if (!fileName || typeof fileName !== \"string\") {\n      throw new Error(\"fileName parameter is mandatory\");\n    }\n\n    if (!(file instanceof File) && !(file instanceof Blob) &&\n        !(window.IDBMutableFile && file instanceof window.IDBMutableFile) &&\n        !(file instanceof IDBPromisedMutableFile)) {\n      throw new Error(`Unable to persist ${fileName}. Unknown file type.`);\n    }\n\n    if (file instanceof IDBPromisedMutableFile) {\n      file = file.mutableFile;\n    }\n\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.put(file, fileName));\n  }\n\n  /**\n   * Remove a file object from the IDBFileStorage.\n   *\n   * @param {string} fileName\n   *   The fileName (the associated IndexedDB key) to remove from the IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved when the request has been completed.\n   */\n  async remove(fileName) {\n    if (!fileName) {\n      throw new Error(\"fileName parameter is mandatory\");\n    }\n\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.delete(fileName));\n  }\n\n  /**\n   * List the names of the files stored in the IDBFileStorage.\n   *\n   * (If any filtering options has been specified, only the file names that match\n   * all the filters are included in the result).\n   *\n   * @param {IDBFileStorage.ListFilteringOptions} options\n   *   The optional filters to apply while listing the stored file names.\n   *\n   * @returns {Promise<string[]>}\n   *   A promise resolved to the array of the filenames that has been found.\n   */\n  async list(options) {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb});\n    const allKeys = await waitForDOMRequest(objectStore.getAllKeys());\n\n    let filteredKeys = allKeys;\n\n    if (options) {\n      filteredKeys = filteredKeys.filter(key => {\n        let match = true;\n\n        if (typeof options.startsWith === \"string\") {\n          match = match && key.startsWith(options.startsWith);\n        }\n\n        if (typeof options.endsWith === \"string\") {\n          match = match && key.endsWith(options.endsWith);\n        }\n\n        if (typeof options.includes === \"string\") {\n          match = match && key.includes(options.includes);\n        }\n\n        if (typeof options.filterFn === \"function\") {\n          match = match && options.filterFn(key);\n        }\n\n        return match;\n      });\n    }\n\n    return filteredKeys;\n  }\n\n  /**\n   * Count the number of files stored in the IDBFileStorage.\n   *\n   * (If any filtering options has been specified, only the file names that match\n   * all the filters are included in the final count).\n   *\n   * @param {IDBFileStorage.ListFilteringOptions} options\n   *   The optional filters to apply while listing the stored file names.\n   *\n   * @returns {Promise<number>}\n   *   A promise resolved to the number of files that has been found.\n   */\n  async count(options) {\n    if (!options) {\n      const idb = await this.initializedDB();\n      const objectStore = this.getObjectStoreTransaction({idb});\n      return waitForDOMRequest(objectStore.count());\n    }\n\n    const filteredKeys = await this.list(options);\n    return filteredKeys.length;\n  }\n\n  /**\n   * Retrieve a file stored in the IDBFileStorage by key.\n   *\n   * @param {string} fileName\n   *   The key to use to retrieve the file from the IDBFileStorage.\n   *\n   * @returns {Promise<Blob|File|IDBPromisedMutableFile>}\n   *   A promise resolved once the file stored in the IDBFileStorage has been retrieved.\n   */\n  async get(fileName) {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb});\n    return waitForDOMRequest(objectStore.get(fileName)).then(result => {\n      if (window.IDBMutableFile && result instanceof window.IDBMutableFile) {\n        return new IDBPromisedMutableFile({\n          filesStorage: this,\n          idb,\n          fileName,\n          fileType: result.type,\n          mutableFile: result\n        });\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * Remove all the file objects stored in the IDBFileStorage.\n   *\n   * @returns {Promise}\n   *   A promise resolved once the IDBFileStorage has been cleared.\n   */\n  async clear() {\n    const idb = await this.initializedDB();\n    const objectStore = this.getObjectStoreTransaction({idb, mode: \"readwrite\"});\n    return waitForDOMRequest(objectStore.clear());\n  }\n}\n\n/**\n * Retrieve an IDBFileStorage instance by name (and it creates the indexedDB if it doesn't\n * exist yet).\n *\n * @param {Object} [param]\n * @param {string} [param.name=\"default\"]\n *   The name associated to the IDB File Storage.\n * @param {boolean} [param.persistent]\n *   Optionally enable persistent storage mode (not enabled by default).\n *\n * @returns {IDBFileStorage}\n *   The IDBFileStorage instance with the given name.\n */\nexport async function getFileStorage({name, persistent} = {}) {\n  const filesStorage = new IDBFileStorage({name: name || \"default\", persistent});\n  await filesStorage.initializedDB();\n  return filesStorage;\n}\n\n/**\n * @external {Blob} https://developer.mozilla.org/en-US/docs/Web/API/Blob\n */\n\n/**\n * @external {DOMRequest} https://developer.mozilla.org/en/docs/Web/API/DOMRequest\n */\n\n/**\n * @external {File} https://developer.mozilla.org/en-US/docs/Web/API/File\n */\n\n/**\n * @external {IDBMutableFile} https://developer.mozilla.org/en-US/docs/Web/API/IDBMutableFile\n */\n\n/**\n * @external {IDBRequest} https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest\n */\n"]}