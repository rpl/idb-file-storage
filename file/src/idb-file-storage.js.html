<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/idb-file-storage.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/idb-file-storage.js~IDBFileStorage.html">IDBFileStorage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/idb-file-storage.js~IDBPromisedFileHandle.html">IDBPromisedFileHandle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/idb-file-storage.js~IDBPromisedMutableFile.html">IDBPromisedMutableFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getFileStorage">getFileStorage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-waitForDOMRequest">waitForDOMRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IDBFileStorage.ListFilteringOptions">IDBFileStorage.ListFilteringOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-IDBPromisedFileHandle.Metadata">IDBPromisedFileHandle.Metadata</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">Blob</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en/docs/Web/API/DOMRequest">DOMRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/File">File</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBMutableFile">IDBMutableFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest">IDBRequest</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/idb-file-storage.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;

/**
 * @typedef {Object} IDBPromisedFileHandle.Metadata
 * @property {number} size
 *   The size of the file in bytes.
 * @property {Date} last Modified
 *   The time and date of the last change to the file.
 */

/**
 * @typedef {Object} IDBFileStorage.ListFilteringOptions
 * @property {string} startsWith
 *   A string to be checked with `fileNameString.startsWith(...)`.
 * @property {string} endsWith
 *   A string to be checked with  `fileNameString.endsWith(...)`.
 * @property {string} includes
 *   A string to be checked with `fileNameString.includes(...)`.
 * @property {function} filterFn
 *   A function to be used to check the file name (`filterFn(fileNameString)`).
 */

/**
 * Wraps a DOMRequest into a promise, optionally transforming the result using the onsuccess
 * callback.
 *
 * @param {IDBRequest|DOMRequest} req
 *   The DOMRequest instance to wrap in a Promise.
 * @param {function}  [onsuccess]
 *   An optional onsuccess callback which can transform the result before resolving it.
 *
 * @returns {Promise}
 *   The promise which wraps the request result, rejected if the request.onerror has been
 *   called.
 */
export function waitForDOMRequest(req, onsuccess) {
  return new Promise((resolve, reject) =&gt; {
    req.onsuccess = onsuccess ?
      (() =&gt; resolve(onsuccess(req.result))) : (() =&gt; resolve(req.result));
    req.onerror = () =&gt; reject(req.error);
  });
}

/**
 * Wraps an IDBMutableFile&apos;s FileHandle with a nicer Promise-based API.
 *
 * Instances of this class are created from the
 * {@link IDBPromisedMutableFile.open} method.
 */
export class IDBPromisedFileHandle {
  /**
   * @private private helper method used internally.
   */
  constructor({file, lockedFile}) {
    // All the following properties are private and it should not be needed
    // while using the API.

    /** @private */
    this.file = file;
    /** @private */
    this.lockedFile = lockedFile;
    /** @private */
    this.writeQueue = Promise.resolve();
    /** @private */
    this.closed = undefined;
    /** @private */
    this.aborted = undefined;
  }

  /**
   * @private private helper method used internally.
   */
  ensureLocked({invalidMode} = {}) {
    if (this.closed) {
      throw new Error(&quot;FileHandle has been closed&quot;);
    }

    if (this.aborted) {
      throw new Error(&quot;FileHandle has been aborted&quot;);
    }

    if (!this.lockedFile) {
      throw new Error(&quot;Invalid FileHandled&quot;);
    }

    if (invalidMode &amp;&amp; this.lockedFile.mode === invalidMode) {
      throw new Error(`FileHandle should not be opened as &apos;${this.lockedFile.mode}&apos;`);
    }
    if (!this.lockedFile.active) {
      // Automatically relock the file with the last open mode
      this.file.reopenFileHandle(this);
    }
  }

  // Promise-based MutableFile API

  /**
   * Provide access to the mode that has been used to open the {@link IDBPromisedMutableFile}.
   *
   * @type {&quot;readonly&quot;|&quot;readwrite&quot;|&quot;writeonly&quot;}
   */
  get mode() {
    return this.lockedFile.mode;
  }

  /**
   * A boolean property that is true if the lock is still active.
   *
   * @type {boolean}
   */
  get active() {
    return this.lockedFile ? this.lockedFile.active : false;
  }

  /**
   * Close the locked file (and wait for any written data to be flushed if needed).
   *
   * @returns {Promise}
   *   A promise which is resolved when the close request has been completed
   */
  async close() {
    if (!this.lockedFile) {
      throw new Error(&quot;FileHandle is not open&quot;);
    }

    // Wait the queued write to complete.
    await this.writeQueue;

    // Wait for flush request to complete if needed.
    if (this.lockedFile.active &amp;&amp; this.lockedFile.mode !== &quot;readonly&quot;) {
      await waitForDOMRequest(this.lockedFile.flush());
    }

    this.closed = true;
    this.lockedFile = null;
    this.writeQueue = Promise.resolve();
  }

  /**
   * Abort any pending data request and set the instance as aborted.
   *
   * @returns {Promise}
   *   A promise which is resolved when the abort request has been completed
   */
  async abort() {
    if (this.lockedFile.active) {
      // NOTE: in the docs abort is reported to return a DOMRequest, but it doesn&apos;t seem
      // to be the case. (https://developer.mozilla.org/en-US/docs/Web/API/LockedFile/abort)
      this.lockedFile.abort();
    }

    this.aborted = true;
    this.lockedFile = null;
    this.writeQueue = Promise.resolve();
  }

  /**
   * Get the file metadata (take a look to {@link IDBPromisedFileHandle.Metadata} for more info).
   *
   * @returns {Promise&lt;{size: number, lastModified: Date}&gt;}
   *   A promise which is resolved when the request has been completed
   */
  async getMetadata() {
    this.ensureLocked();
    return waitForDOMRequest(this.lockedFile.getMetadata());
  }

  /**
   * Read a given amount of data from the file as Text (optionally starting from the specified
   * location).
   *
   * @param {number} size
   *   The amount of data to read.
   * @param {number} [location]
   *   The location where the request should start to read the data.
   *
   * @returns {Promise&lt;string&gt;}
   *   A promise which resolves to the data read, when the request has been completed.
   */
  async readAsText(size, location) {
    this.ensureLocked({invalidMode: &quot;writeonly&quot;});
    if (typeof location === &quot;number&quot;) {
      this.lockedFile.location = location;
    }
    return waitForDOMRequest(this.lockedFile.readAsText(size));
  }

  /**
   * Read a given amount of data from the file as an ArrayBufer (optionally starting from the specified
   * location).
   *
   * @param {number} size
   *   The amount of data to read.
   * @param {number} [location]
   *   The location where the request should start to read the data.
   *
   * @returns {Promise&lt;ArrayBuffer&gt;}
   *   A promise which resolves to the data read, when the request has been completed.
   */
  async readAsArrayBuffer(size, location) {
    this.ensureLocked({invalidMode: &quot;writeonly&quot;});
    if (typeof location === &quot;number&quot;) {
      this.lockedFile.location = location;
    }
    return waitForDOMRequest(this.lockedFile.readAsArrayBuffer(size));
  }

  /**
   * Truncate the file (optionally at a specified location).
   *
   * @param {number} [location=0]
   *   The location where the file should be truncated.
   *
   * @returns {Promise&lt;ArrayBuffer&gt;}
   *   A promise which is resolved once the request has been completed.
   */
  async truncate(location = 0) {
    this.ensureLocked({invalidMode: &quot;readonly&quot;});
    return waitForDOMRequest(this.lockedFile.truncate(location));
  }

  /**
   * Append the passed data to the end of the file.
   *
   * @param {string|ArrayBuffer} data
   *   The data to append to the end of the file.
   *
   * @returns {Promise}
   *   A promise which is resolved once the request has been completed.
   */
  async append(data) {
    this.ensureLocked({invalidMode: &quot;readonly&quot;});
    return waitForDOMRequest(this.lockedFile.append(data));
  }

  /**
   * Write data into the file (optionally starting from a defined location in the file).
   *
   * @param {string|ArrayBuffer} data
   *   The data to write into the file.
   * @param {number} location
   *   The location where the data should be written.
   *
   * @returns {Promise&lt;number&gt;}
   *   A promise which is resolved to the location where the written data ends.
   */
  async write(data, location) {
    this.ensureLocked({invalidMode: &quot;readonly&quot;});
    if (typeof location === &quot;number&quot;) {
      this.lockedFile.location = location;
    }
    return waitForDOMRequest(
      this.lockedFile.write(data),
      // Resolves to the new location.
      () =&gt; {
        return this.lockedFile.location;
      }
    );
  }

  /**
   * Queue data to be written into the file (optionally starting from a defined location in the file).
   *
   * @param {string|ArrayBuffer} data
   *   The data to write into the file.
   * @param {number} location
   *   The location where the data should be written (when not specified the end of the previous
   *   queued write is used).
   *
   * @returns {Promise&lt;number&gt;}
   *   A promise which is resolved once the request has been completed with the location where the
   *   file was after the data has been writted.
   */
  queuedWrite(data, location) {
    const nextWriteRequest = async lastLocation =&gt; {
      this.ensureLocked({invalidMode: &quot;readonly&quot;});

      if (typeof location === &quot;number&quot;) {
        return this.write(data, location);
      }
      return this.write(data, lastLocation);
    };

    this.writeQueue = this.writeQueue.then(nextWriteRequest);
    return this.writeQueue;
  }

  /**
   * Wait that any queued data has been written.
   *
   * @returns {Promise&lt;number&gt;}
   *   A promise which is resolved once the request has been completed with the location where the
   *   file was after the data has been writted.
   */
  async waitForQueuedWrites() {
    await this.writeQueue;
  }
}

/**
 * Wraps an IDBMutableFile with a nicer Promise-based API.
 *
 * Instances of this class are created from the
 * {@link IDBFileStorage.createMutableFile} method.
 */
export class IDBPromisedMutableFile {
  /**
   * @private private helper method used internally.
   */
  constructor({filesStorage, idb, fileName, fileType, mutableFile}) {
    // All the following properties are private and it should not be needed
    // while using the API.

    /** @private */
    this.filesStorage = filesStorage;
    /** @private */
    this.idb = idb;
    /** @private */
    this.fileName = fileName;
    /** @private */
    this.fileType = fileType;
    /** @private */
    this.mutableFile = mutableFile;
  }

  /**
   * @private private helper method used internally.
   */
  reopenFileHandle(fileHandle) {
    fileHandle.lockedFile = this.mutableFile.open(fileHandle.mode);
  }

  // API methods.

  /**
   * Open a mutable file for reading/writing data.
   *
   * @param {&quot;readonly&quot;|&quot;readwrite&quot;|&quot;writeonly&quot;} mode
   *   The mode of the created IDBPromisedFileHandle instance.
   *
   * @returns {IDBPromisedFileHandle}
   *   The created IDBPromisedFileHandle instance.
   */
  open(mode) {
    if (this.lockedFile) {
      throw new Error(&quot;MutableFile cannot be opened twice&quot;);
    }
    const lockedFile = this.mutableFile.open(mode);

    return new IDBPromisedFileHandle({file: this, lockedFile});
  }

  /**
   * Get a {@link File} instance of this mutable file.
   *
   * @returns {Promise&lt;File&gt;}
   *   A promise resolved to the File instance.
   *
   * To read the actual content of the mutable file as a File object,
   * it is often better to use {@link IDBPromisedMutableFile.saveAsFileSnapshot}
   * to save a persistent snapshot of the file in the IndexedDB store,
   * or reading it directly using the {@link IDBPromisedFileHandle} instance
   * returned by the {@link IDBPromisedMutableFile.open} method.
   *
   * The reason is that to be able to read the content of the returned file
   * a lockfile have be keep the file open, e.d. as in the following example.
   *
   * @example
   *     ...
   *     let waitSnapshotStored;
   *     await mutableFile.runFileRequestGenerator(function* (lockedFile) {
   *       const file = yield lockedFile.mutableFile.getFile();
   *       // read the file content or turn it into a persistent object of its own
   *       // (e.g. by saving it back into IndexedDB as its snapshot in form of a File object,
   *       // or converted into a data url, a string or an array buffer)
   *
   *       waitSnapshotStored = tmpFiles.put(&quot;${filename}/last_snapshot&quot;, file);
   *     }
   *
   *     await waitSnapshotStored;
   *     let fileSnapshot = await tmpFiles.get(&quot;${filename}/last_snapshot&quot;);
   *     ...
   *     // now you can use fileSnapshot even if the mutableFile lock is not active anymore.
   */
  getFile() {
    return waitForDOMRequest(this.mutableFile.getFile());
  }

  /**
   * Persist the content of the mutable file into the files storage
   * as a File, using the specified snapshot name and return the persisted File instance.
   *
   * @returns {Promise&lt;File&gt;}
   *   A promise resolved to the File instance.
   *
   * @example
   *
   *      const file = await mutableFile.persistAsFileSnapshot(`${filename}/last_snapshot`);
   *      const blobURL = URL.createObjectURL(file);
   *      ...
   *      // The blob URL is still valid even if the mutableFile is not active anymore.
   */
  async persistAsFileSnapshot(snapshotName) {
    if (snapshotName === this.fileName) {
      throw new Error(&quot;Snapshot name and the file name should be different&quot;);
    }

    const idb = await this.filesStorage.initializedDB();
    await this.runFileRequestGenerator(function* () {
      const file = yield this.mutableFile.getFile();
      const objectStore = this.filesStorage.getObjectStoreTransaction({idb, mode: &quot;readwrite&quot;});

      yield objectStore.put(file, snapshotName);
    }.bind(this));

    return this.filesStorage.get(snapshotName);
  }

  /**
   * Persist the this mutable file into its related IDBFileStorage.
   *
   * @returns {Promise}
   *   A promise resolved on the mutable file has been persisted into IndexedDB.
   */
  persist() {
    return this.filesStorage.put(this.fileName, this);
  }

  /**
   * Run a generator function which can run a sequence of FileRequests
   * without the lockfile to become inactive.
   *
   * This method should be rarely needed, mostly to optimize a sequence of
   * file operations without the file to be closed and automatically re-opened
   * between two file requests.
   *
   * @param {function* (lockedFile) {...}} generatorFunction
   * @param {&quot;readonly&quot;|&quot;readwrite&quot;|&quot;writeonly&quot;} mode
   *
   * @example
   *   (async function () {
   *      const tmpFiles = await IDBFiles.getFileStorage({name: &quot;tmpFiles&quot;});
   *      const mutableFile = await tmpFiles.createMutableFile(&quot;test-mutable-file.txt&quot;);
   *
   *      let allFileData;
   *
   *      function* fileOperations(lockedFile) {
   *        yield lockedFile.write(&quot;some data&quot;);
   *        yield lockedFile.write(&quot;more data&quot;);
   *        const metadata = yield lockedFile.getMetadata();
   *
   *        lockedFile.location = 0;
   *        allFileData = yield lockedFile.readAsText(metadata.size);
   *      }
   *
   *      await mutableFile.runFileRequestGenerator(fileOperations, &quot;readwrite&quot;);
   *
   *      console.log(&quot;File Data&quot;, allFileData);
   *   })();
   */
  async runFileRequestGenerator(generatorFunction, mode) {
    if (generatorFunction.constructor.name !== &quot;GeneratorFunction&quot;) {
      throw new Error(&quot;runGenerator parameter should be a generator function&quot;);
    }

    await new Promise((resolve, reject) =&gt; {
      const lockedFile = this.mutableFile.open(mode || &quot;readwrite&quot;);
      const fileRequestsIter = generatorFunction(lockedFile);

      const processFileRequestIter = prevRequestResult =&gt; {
        const nextFileRequest = fileRequestsIter.next(prevRequestResult);
        if (nextFileRequest.done) {
          resolve();
          return;
        } else if (!(nextFileRequest.value instanceof window.DOMRequest ||
                     nextFileRequest.value instanceof window.IDBRequest)) {
          const error = new Error(&quot;FileRequestGenerator should only yield DOMRequest instances&quot;);
          fileRequestsIter.throw(error);
          reject(error);
          return;
        }

        const request = nextFileRequest.value;
        if (request.onsuccess || request.onerror) {
          const error = new Error(&quot;DOMRequest onsuccess/onerror callbacks are already set&quot;);
          fileRequestsIter.throw(error);
          reject(error);
        } else {
          request.onsuccess = () =&gt; processFileRequestIter(request.result);
          request.onerror = () =&gt; reject(request.error);
        }
      };

      processFileRequestIter();
    });
  }
}

/**
 * Provides a Promise-based API to store files into an IndexedDB.
 *
 * Instances of this class are created using the exported
 * {@link getFileStorage} function.
 */
export class IDBFileStorage {
  /**
   * @private private helper method used internally.
   */
  constructor({name, persistent} = {}) {
    // All the following properties are private and it should not be needed
    // while using the API.

    /** @private */
    this.name = name;
    /** @private */
    this.persistent = persistent;
    /** @private */
    this.indexedDBName = `IDBFilesStorage-DB-${this.name}`;
    /** @private */
    this.objectStorageName = &quot;IDBFilesObjectStorage&quot;;
    /** @private */
    this.initializedPromise = undefined;

    // TODO: evalutate schema migration between library versions?
    /** @private */
    this.version = 1.0;
  }

  /**
   * @private private helper method used internally.
   */
  initializedDB() {
    if (this.initializedPromise) {
      return this.initializedPromise;
    }

    this.initializedPromise = (async () =&gt; {
      if (window.IDBMutableFile &amp;&amp; this.persistent) {
        this.version = {version: this.version, storage: &quot;persistent&quot;};
      }
      const dbReq = indexedDB.open(this.indexedDBName, this.version);

      dbReq.onupgradeneeded = () =&gt; {
        const db = dbReq.result;
        if (!db.objectStoreNames.contains(this.objectStorageName)) {
          db.createObjectStore(this.objectStorageName);
        }
      };

      return waitForDOMRequest(dbReq);
    })();

    return this.initializedPromise;
  }

  /**
   * @private private helper method used internally.
   */
  getObjectStoreTransaction({idb, mode} = {}) {
    const transaction = idb.transaction([this.objectStorageName], mode);
    return transaction.objectStore(this.objectStorageName);
  }

  /**
   * Create a new IDBPromisedMutableFile instance (where the IDBMutableFile is supported)
   *
   * @param {string} fileName
   *   The fileName associated to the new IDBPromisedMutableFile instance.
   * @param {string} [fileType=&quot;text&quot;]
   *   The mime type associated to the file.
   *
   * @returns {IDBPromisedMutableFile}
   *   The newly created {@link IDBPromisedMutableFile} instance.
   */
  async createMutableFile(fileName, fileType = &quot;text&quot;) {
    if (!window.IDBMutableFile) {
      throw new Error(&quot;This environment does not support IDBMutableFile&quot;);
    }
    const idb = await this.initializedDB();
    const mutableFile = await waitForDOMRequest(
      idb.createMutableFile(fileName, fileType)
    );
    return new IDBPromisedMutableFile({
      filesStorage: this, idb, fileName, fileType, mutableFile
    });
  }

  /**
   * Put a file object into the IDBFileStorage, it overwrites an existent file saved with the
   * fileName if any.
   *
   * @param {string} fileName
   *   The key associated to the file in the IDBFileStorage.
   * @param {Blob|File|IDBPromisedMutableFile|IDBMutableFile} file
   *   The file to be persisted.
   *
   * @returns {Promise}
   *   A promise resolved when the request has been completed.
   */
  async put(fileName, file) {
    if (!fileName || typeof fileName !== &quot;string&quot;) {
      throw new Error(&quot;fileName parameter is mandatory&quot;);
    }

    if (!(file instanceof File) &amp;&amp; !(file instanceof Blob) &amp;&amp;
        !(window.IDBMutableFile &amp;&amp; file instanceof window.IDBMutableFile) &amp;&amp;
        !(file instanceof IDBPromisedMutableFile)) {
      throw new Error(`Unable to persist ${fileName}. Unknown file type.`);
    }

    if (file instanceof IDBPromisedMutableFile) {
      file = file.mutableFile;
    }

    const idb = await this.initializedDB();
    const objectStore = this.getObjectStoreTransaction({idb, mode: &quot;readwrite&quot;});
    return waitForDOMRequest(objectStore.put(file, fileName));
  }

  /**
   * Remove a file object from the IDBFileStorage.
   *
   * @param {string} fileName
   *   The fileName (the associated IndexedDB key) to remove from the IDBFileStorage.
   *
   * @returns {Promise}
   *   A promise resolved when the request has been completed.
   */
  async remove(fileName) {
    if (!fileName) {
      throw new Error(&quot;fileName parameter is mandatory&quot;);
    }

    const idb = await this.initializedDB();
    const objectStore = this.getObjectStoreTransaction({idb, mode: &quot;readwrite&quot;});
    return waitForDOMRequest(objectStore.delete(fileName));
  }

  /**
   * List the names of the files stored in the IDBFileStorage.
   *
   * (If any filtering options has been specified, only the file names that match
   * all the filters are included in the result).
   *
   * @param {IDBFileStorage.ListFilteringOptions} options
   *   The optional filters to apply while listing the stored file names.
   *
   * @returns {Promise&lt;string[]&gt;}
   *   A promise resolved to the array of the filenames that has been found.
   */
  async list(options) {
    const idb = await this.initializedDB();
    const objectStore = this.getObjectStoreTransaction({idb});
    const allKeys = await waitForDOMRequest(objectStore.getAllKeys());

    let filteredKeys = allKeys;

    if (options) {
      filteredKeys = filteredKeys.filter(key =&gt; {
        let match = true;

        if (typeof options.startsWith === &quot;string&quot;) {
          match = match &amp;&amp; key.startsWith(options.startsWith);
        }

        if (typeof options.endsWith === &quot;string&quot;) {
          match = match &amp;&amp; key.endsWith(options.endsWith);
        }

        if (typeof options.includes === &quot;string&quot;) {
          match = match &amp;&amp; key.includes(options.includes);
        }

        if (typeof options.filterFn === &quot;function&quot;) {
          match = match &amp;&amp; options.filterFn(key);
        }

        return match;
      });
    }

    return filteredKeys;
  }

  /**
   * Count the number of files stored in the IDBFileStorage.
   *
   * (If any filtering options has been specified, only the file names that match
   * all the filters are included in the final count).
   *
   * @param {IDBFileStorage.ListFilteringOptions} options
   *   The optional filters to apply while listing the stored file names.
   *
   * @returns {Promise&lt;number&gt;}
   *   A promise resolved to the number of files that has been found.
   */
  async count(options) {
    if (!options) {
      const idb = await this.initializedDB();
      const objectStore = this.getObjectStoreTransaction({idb});
      return waitForDOMRequest(objectStore.count());
    }

    const filteredKeys = await this.list(options);
    return filteredKeys.length;
  }

  /**
   * Retrieve a file stored in the IDBFileStorage by key.
   *
   * @param {string} fileName
   *   The key to use to retrieve the file from the IDBFileStorage.
   *
   * @returns {Promise&lt;Blob|File|IDBPromisedMutableFile&gt;}
   *   A promise resolved once the file stored in the IDBFileStorage has been retrieved.
   */
  async get(fileName) {
    const idb = await this.initializedDB();
    const objectStore = this.getObjectStoreTransaction({idb});
    return waitForDOMRequest(objectStore.get(fileName)).then(result =&gt; {
      if (window.IDBMutableFile &amp;&amp; result instanceof window.IDBMutableFile) {
        return new IDBPromisedMutableFile({
          filesStorage: this,
          idb,
          fileName,
          fileType: result.type,
          mutableFile: result
        });
      }

      return result;
    });
  }

  /**
   * Remove all the file objects stored in the IDBFileStorage.
   *
   * @returns {Promise}
   *   A promise resolved once the IDBFileStorage has been cleared.
   */
  async clear() {
    const idb = await this.initializedDB();
    const objectStore = this.getObjectStoreTransaction({idb, mode: &quot;readwrite&quot;});
    return waitForDOMRequest(objectStore.clear());
  }
}

/**
 * Retrieve an IDBFileStorage instance by name (and it creates the indexedDB if it doesn&apos;t
 * exist yet).
 *
 * @param {Object} [param]
 * @param {string} [param.name=&quot;default&quot;]
 *   The name associated to the IDB File Storage.
 * @param {boolean} [param.persistent]
 *   Optionally enable persistent storage mode (not enabled by default).
 *
 * @returns {IDBFileStorage}
 *   The IDBFileStorage instance with the given name.
 */
export async function getFileStorage({name, persistent} = {}) {
  const filesStorage = new IDBFileStorage({name: name || &quot;default&quot;, persistent});
  await filesStorage.initializedDB();
  return filesStorage;
}

/**
 * @external {Blob} https://developer.mozilla.org/en-US/docs/Web/API/Blob
 */

/**
 * @external {DOMRequest} https://developer.mozilla.org/en/docs/Web/API/DOMRequest
 */

/**
 * @external {File} https://developer.mozilla.org/en-US/docs/Web/API/File
 */

/**
 * @external {IDBMutableFile} https://developer.mozilla.org/en-US/docs/Web/API/IDBMutableFile
 */

/**
 * @external {IDBRequest} https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest
 */
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
